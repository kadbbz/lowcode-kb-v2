# 低代码诞生的背景

低代码技术并非凭空出现，而是企业软件需求长期扩张、软件复杂度持续累积，以及传统开发模式在规模化过程中不断暴露瓶颈的共同结果。从更宏观的视角看，低代码是成本导向原则在企业软件领域的一次集中体现：当软件需求的增长速度持续超过开发人力与工程效率的提升速度时，行业必然会寻找新的生产方式。

## 一、企业软件复杂度的逐步累积

### 1.1 从硬件导向到数据导向

早期的软件开发几乎完全围绕计算机硬件展开。机器语言与汇编语言要求开发者理解CPU指令、寄存器和内存地址，软件的表达方式高度依赖具体硬件体系结构，如SSE指令集中用于比较字符串的pcmpistr，无法运行在不支持SSE的CPU上。这一阶段的软件极其昂贵、开发周期漫长、可复用性极低，应用范围也因此被限制在政府、科研机构和少数大型企业的核心场景中。随着电子工业的发展，计算机开始进入企业管理领域。跨行业、跨规模推广计算机应用的关键，在于找到一种足够通用的抽象方式。

1970年，来自IBM的E.F.Codd博士在ACM通讯杂志上发表的论文《大规模共享数据银行的关系型模型》，为解决这一问题提供了一种切实可行的技术路线。该路线中，现实世界中的业务单据、业务流程和管理决策，被统一抽象为**数据**的存储、处理与分析，而执行这些操作的软件被统称为“关系型数据库”。企业的用户只需要一个连接到数据库软件的终端，就能用一套近似于英语的、统一的语言来操作这个软件，以此实现所有的业务操作。如用户想要查询姓名中包含“李”的员工档案，需要输入 SELECT \* FROM STAFFS WHERE NAME LIKE ‘%李%’ ，界面上就会呈现出纯文本呈现的员工档案信息。

![image](/DOCUMENT_SITE_LINK_PREFIX_HERE/document-site-files/images/857092bc-61d4-4e04-9cb6-4b270c3c0a5e/image-20260108.f3704e.png?width=800)
*图：早期的数据库服务器与操作终端*

关系型数据库的出现，标志着企业软件第一次在抽象层面实现了规模化。通过关系模型描述业务实体及其关系，通过统一的数据操作语言处理不同业务场景，数据库成功降低了企业信息化的技术门槛，也显著扩展了软件需求的边界。

### 1.2 “壳”的出现与复杂度外溢

当数据库从档案管理走向财务、库存、成本核算等复杂业务场景时，一个新的问题随之出现：直接操作SQL对最终用户并不友好，一个业务操作需要多次打印和重复输入，导致操作员工作负荷高、出错概率大。为此，行业选择将数据库抽象为数据模型（数据模型可近似理解为数据库的结构，由数据表、列和表关系构成），在模型之上构建应用软件。这种做法很像是给数据库“套壳”，让用户操作应用，应用去操作数据库，而非用户直接操作数据库。

这一决策带来了企业软件形态的根本变化。业务逻辑开始在数据库与应用程序之间重新分配，用户交互界面成为差异化竞争的核心。随着抽象度更高的新一代高级语言（如C++、Java语言）在应用层的普及，企业软件正式进入“**高级语言 + 数据库**”的长期技术范式。

![image](/DOCUMENT_SITE_LINK_PREFIX_HERE/document-site-files/images/857092bc-61d4-4e04-9cb6-4b270c3c0a5e/image-20260108.2aa08b.png)
*图：DOS时代的企业软件操作界面*

然而，这种分层结构也埋下了复杂度累积的种子：

- 数据模型持续膨胀：一个小型订单管理系统可能只有十几张表，但经过几年演进后，堪比ERP的系统重，表数量可能增长到数百张
- 业务规则不断叠加：每次业务流程调整都会增加新的验证规则、计算公式和例外处理逻辑
- 交互逻辑日益复杂：从简单的表单录入发展到复杂的向导流程、多标签页面和实时校验
- 应用规模和生命周期显著拉长：企业软件往往需要运行十年甚至更长时间，期间不断打补丁和加功能

企业软件不再是一次性交付的工具，而是需要多年演进、持续维护的复杂系统。

***

## 二、传统开发模式在规模化后的核心瓶颈

在高级语言诞生后的相当长一段时间内，行业普遍认为：只要语言不断演进、工具不断完善，软件开发效率就可以持续线性提升。然而，当企业软件进入中大型规模，并在真实组织环境中长期运行后，这一判断开始失效。问题并不主要出在语言本身，而是出在**传统开发模式与企业软件现实约束之间的结构性错位**。

### 2.1 企业软件开发的真实起点：小团队、不稳定需求

与互联网产品不同，大多数企业软件项目并非从“大规模系统”起步，而是从**小团队、小范围需求**开始演进的。一个典型的企业软件项目，往往具有以下特征：

- 单个项目的开发人员规模较小，常见在 3～5 人以内：一个制造企业的生产排程系统，可能只有3名开发者，甚至没有专职的产品经理
- 需求来源复杂，往往来自业务部门的阶段性诉求：财务部门要求增加多币种支持，采购部门要求增加供应商评级，这些需求在对应系统的立项之初，往往没有统筹规划
- 需求本身不稳定，存在频繁调整、回滚和例外情况：一条审批规则可能因为组织架构调整而每季度修改一次
- 软件生命周期长，项目交付只是开始而非结束：许多企业软件会运行5-10年，期间经历数十次甚至上百次的需求变更

在这种背景下，传统高级语言开发模式在初期通常“看起来一切正常”。开发者可以通过直接编码的方式快速满足需求，组件和框架也能在一定程度上提升效率。但随着时间推移，系统规模扩大，问题开始显现。

### 2.2 组件化与框架化的效率上限

组件化和框架化，是高级语言时代应对复杂度增长的两种核心手段。它们通过复用代码和架构经验，在早期确实显著提升了开发效率。然而，这种提升并非无限。
> **组件与框架解决的是“写不写得快”的问题，而不是“能不能长期管控”的问题。**
当系统中组件数量不断增加、依赖关系逐渐复杂时，开发者需要投入大量精力去理解组件边界、调用方式和版本兼容性。例如，一个看似简单的日期选择器组件，可能依赖了moment.js做日期处理，依赖了popper.js做弹出定位，依赖了某个图标库做UI渲染。组件越多，组合复杂度越高，整体系统反而更难以掌控。更麻烦的是，当某个底层依赖需要升级以修复安全漏洞时，可能会引发连锁反应，导致数十个组件需要同步更新。

![image](/DOCUMENT_SITE_LINK_PREFIX_HERE/document-site-files/images/857092bc-61d4-4e04-9cb6-4b270c3c0a5e/image-20260108.ded7a3.png?width=800)
*图：一个小型编码开发项目依赖的组件与频繁更新版本*

框架在规范结构方面发挥了更大的作用，但它的价值同样存在边界。框架能够约束“系统长什么样”（例如MVC架构规定了Model、View、Controller的分层），却很难约束“业务逻辑应该如何表达”。在企业软件中，大量复杂性正是来源于业务规则本身——比如"采购金额超过10万需要总经理审批，但IT类采购无论金额都需要CTO审批，除非是紧急采购且提前在钉钉群中知会"。这些规则最终仍然以命令式代码的形式分散在各个模块中，框架对此无能为力。
当团队规模较小、人员相对稳定时，这种复杂性尚可通过经验和默契来消化；一旦进入多人协作、长期演进阶段，问题便会集中爆发，尤其是当出现人员变动时。

### 2.3 “千人千面”的代码与规范化困境

在传统开发模式下，即便使用同一语言、同一框架，不同开发人员对需求的理解、对平台机制的掌握程度、对编码风格的偏好，都会直接反映在代码中。
以一个常见的场景为例：实现"订单金额根据客户VIP等级打折"的功能。
开发者A的实现是过程式风格：

```java
public double calculatePrice(Order order) {
    double price = order.getAmount();
    int vipLevel = order.getCustomer().getVipLevel();
    if (vipLevel == 1) {
        price = price * 0.95;
    } else if (vipLevel == 2) {
        price = price * 0.9;
    } else if (vipLevel >= 3) {
        price = price * 0.85;
    }
    return price;
}
```

开发者B的实现是策略模式：

```java
public interface DiscountStrategy {
    double apply(double price);
}

public class VipDiscountStrategy implements DiscountStrategy {
    private Map<Integer, Double> discountRates;
    // ...构造函数和实现
}

public double calculatePrice(Order order) {
    DiscountStrategy strategy = strategyFactory.getStrategy(order);
    return strategy.apply(order.getAmount());
}
```

开发者C的实现则是更灵活的配置驱动：

```java
// 从数据库表discount_rules读取规则
public double calculatePrice(Order order) {
    List<DiscountRule> rules = discountRuleRepository
        .findByCustomerType(order.getCustomer().getType());
    return rules.stream()
        .filter(rule -> rule.matches(order))
        .findFirst()
        .map(rule -> rule.apply(order.getAmount()))
        .orElse(order.getAmount());
}
```

上面举例的三种实现，在功能上等价，但在可维护性、可测试性和可理解性上差异巨大：

- A的实现最直观，但规则变更需要修改代码
- B的实现扩展性好，但新人需要理解整个策略模式的结构
- C的实现最灵活，但规则分散在数据库中，调试困难

当系统中存在数百个类似的业务逻辑，每个都有不同的实现风格时，结果是：

- 同一类业务逻辑存在多种实现方式，新人无所适从
- 相同功能在不同模块中呈现出完全不同的结构，难以形成统一认知
- 代码可读性、可维护性高度依赖原作者，一旦原作者离职，接手成本极高

企业往往试图通过**编码规范、代码评审、架构委员会**等方式来解决这一问题，但这些手段本质上属于管理层面的补救措施，而非工程范式层面的解决方案。规范越细，执行成本越高；规范越宽，约束效果越弱。
在人员流动不可避免的现实条件下，这种“千人千面”的代码结构，会逐渐演变为技术管理风险。企业可以通过以下三个问题，对这个风险的紧迫性进行快速评估与自查：

- 系统是否还能被新成员理解？
- 核心模块是否只能由少数人维护？
- 一旦平台升级或技术栈变化，改造成本是否可控？

显然，这些问题已经超出了单纯“写代码效率”的讨论范畴。

### 2.4 企业软件与互联网服务的根本差异

暂时抛开技术管理问题。在纯技术选型上，一个常见的误区是，将互联网服务的成功经验直接套用到企业软件开发中。然而，两者在基本约束条件上存在显著差异。
以电商平台的购物车功能为例，互联网服务通常具备以下特征：

- 团队规模大，角色分工高度细化：一个电商平台可能有专门的购物车团队、支付团队、推荐系统团队
- 需求相对稳定，版本节奏可控：购物车的核心逻辑几年内可能都不会有大的变化
- 对并发量和交互复杂度要求极高：需要支持每秒数万次的下单请求，毫秒级的响应时间
- 可以通过规模效应摊薄开发和运维成本：同样的技术投入可以服务百万甚至千万用户，开发人员的成本可以忽略不计

在这种环境下，高度工程化、以代码为中心的开发模式是合理且必要的。投入6个月优化购物车的性能和体验，在千万用户的规模下是完全值得的。但企业软件显然不具备上述条件：

- 团队规模有限，往往需要"一人多职"：同一个开发者可能既要做前端页面，又要写后端逻辑，还要设计数据库结构
- 需求变化频繁，且难以完全预先定义：业务规则和流程可能每个季度都要根据业务变化调整规则
- 并发压力相对可控，但业务规则高度复杂：用户数可能只有几百人，但业务规则可能有数百条，且相互关联
- **成本高度敏感，长期维护成本远高于初始开发成本**：一个系统的5年维护成本可能是初始开发成本的3-5倍

这意味着，企业软件更需要一种**降低表达成本、强化一致性、弱化个人差异**的开发方式，而不是单纯追求性能极限或技术复杂度。为一个只有200个用户的报销系统投入3个月优化响应速度从500ms降低到100ms，往往不如投入同样的时间让系统更容易应对未来的流程变更。

### 2.5 核心瓶颈的本质

综上所述，传统开发模式在企业软件规模化后的核心瓶颈，属于典型的**结构性瓶颈**，并不在于语言是否足够先进、框架是否足够流行，而在于：
> 软件系统的复杂度被长期分散在大量命令式代码和个人决策中，**缺乏可被平台统一理解、治理和演进的表达形式。**
当软件规模尚小时，这种分散复杂度尚可接受；一旦系统进入长期演进阶段，它便会持续放大，并最终成为企业数字化进程中的隐性成本中心。正是在这一背景下，行业开始寻求一种不同于传统开发模式的新路径。

***

## 三、低代码试图回应的根本性问题

当传统开发模式在企业软件规模化过程中逐渐暴露出结构性瓶颈时，行业需要面对的已不再是单点效率问题，而是一个更为根本的命题：
> **在需求持续变化、团队规模受限的现实条件下，如何构建一种可被长期治理和演进的软件生产方式。**
低代码正是在这一问题背景下逐步形成的。

### 3.1 从“实现逻辑”转向“业务能力表达”

在传统开发模式中，业务需求往往被直接翻译为命令式代码。开发者不仅需要表达业务意图，还必须同时决定具体实现路径。这种做法在短期内效率尚可，但会将大量与业务无直接关系的技术细节，永久性地固化进系统。
举一个简单的例子：业务部门提出需求"部门经理提交的出差申请需要总经理审批"。在使用Java/Spring的传统开发模式中，后端开发者需要考虑：

- 在哪个Controller方法里加这个判断？
- 是写在Service层还是在数据库触发器里？
- 审批流程是同步调用还是异步消息？
- 审批状态用什么字段存储？状态机怎么设计？
- 提出人的角色从哪个表查询？缓存策略是什么？

这些决策中，真正与业务需求相关的只有第一条——"提出人的角色包含部门经理，调度到总经理审批"，其余都是技术实现细节。但这些细节一旦写入代码，就会永久性地固化进系统，成为后续演进的负担。更糟糕的是，当半年后需要调整规则为"销售与售前的部门经理提交的出差申请需要副总经理审批"时，开发者需要在数百行代码中找到原来的判断逻辑，理解当时的实现方式，然后小心翼翼地修改，生怕影响到其他逻辑。低代码试图改变的，正是这一默认前提。

低代码的核心思想并非消除专业开发，而是**提升业务表达的抽象层级**，使开发者能够围绕业务能力本身进行建模，而非围绕具体实现细节展开工作。页面结构、数据模型、业务规则、流程策略等，被视为可独立描述、可组合、可演进的对象，而不是散落在代码中的隐含逻辑。

![image](/DOCUMENT_SITE_LINK_PREFIX_HERE/document-site-files/images/857092bc-61d4-4e04-9cb6-4b270c3c0a5e/image-20260108.798e2c.png)
*图：低代码构建的工作流中关于审批条件的定义*

从这个审批场景中看到，低代码的表达方式相比于传统编码的优势在于：

- 业务意图显式化：任何人都能直接看懂这条规则在做什么
- 技术细节被平台吸收：审批任务的创建、状态管理、通知机制都由平台统一处理
- 变更成本显著降低：修改规则只需调整配置，不需要理解底层实现

这种转变，本质上是从“系统如何实现这些功能”转向“系统应该具备什么能力”。与智能化软件工程中所倡导的“声明式编程”的大方向完全贴合。

### 3.2 将工程复杂度内聚到平台层

在传统企业软件中，复杂度往往被分散到每一个项目、每一个模块，甚至每一名开发者的个人决策中。系统规模越大，这种分散复杂度就越难以管理。
> 低代码的一个重要目标，是**将通用且高频的工程复杂度内聚到平台层**。
这些由平台负责处理的工程复杂度包含但不限于：

- 数据存取、事务与权限控制：开发者不需要写SQL，平台根据权限策略自动过滤数据
- 页面与服务端之间的协作机制：表单提交、数据校验、错误处理由平台统一管理
- 流程调度、规则执行与状态管理：审批流转、状态变更、超时提醒由平台引擎驱动
- 与外部系统的集成与运行时保障：API调用、重试机制、日志记录由平台统一封装

而开发者在具体项目中，更多关注差异化的业务策略和业务规则表达。通过这种方式，复杂度不再随着项目数量和人员变动线性增长，而是被平台能力持续吸收和复用。这也是低代码平台往往在长期使用后，才能逐步体现出工程和成本优势的主要原因。

### 3.3 提供平台可理解、可治理的统一表达形式

无论是页面结构、数据模型，还是业务流程与业务规则，在低代码平台中通常以结构化规约（Structured Specification）的形式存在，而非以难以解析的代码文本存在。这一差异并不仅仅体现在“是否可视化”，而在于系统知识的表达方式是否可被平台理解和治理。在传统开发模式中，系统行为主要隐含在代码之中。即便采用了组件化框架、领域模型或设计模式，这些结构仍然依附于具体语言与实现细节，平台本身无法直接理解“一个页面由哪些业务要素构成”“一条规则影响了哪些流程”“某个字段的变更会波及哪些下游逻辑”。这使得工程治理高度依赖个人经验、文档约束和人工评审，且难以规模化。
低代码平台通过将核心要素显式化、结构化，使工程治理得以在代码之上、运行时之前实施。

#### 3.3.1 结构化表达带来的可分析性

在低代码平台中：

- 页面不只是HTML的模板文件，而是由组件树、布局关系和数据绑定关系构成的结构化对象
- 数据模型不仅是单纯的表结构定义，而是包含字段语义、约束、引用关系和生命周期的元数据
- 业务流程与规则以流程图、状态机或规则集的形式存在，展现明确的节点、条件和依赖关系

这种表达方式使系统从“只能被人阅读的文本”，转变为“可以被平台分析的工程对象”。由此，平台可以在文本检索的基础上，为更高层级实施工程治理能力提供支撑，例如：

- 变更影响分析：在修改字段、规则或流程节点之前，自动识别其影响的页面、接口、报表和自动化任务。例如，将"客户类型"字段改名为"客户分类"时，平台可以列出所有需要同步修改的地方，避免遗漏
- 统一校验与约束：对规则冲突、流程死循环、数据约束缺失等问题进行系统级校验，而非依赖人工测试发现。例如，当两条规则分别定义"金额>10000需要CFO审批"和"IT采购无需财务审批"时，平台可以提示这两条规则在"IT采购且金额>10000"的场景下存在冲突
- 行为可追溯性：明确某个系统行为来源于哪条规则、哪个流程节点或哪次配置变更，而非在代码调用链中反向排查。当用户反馈"为什么我的订单被自动驳回了"，管理员可以直接查看是哪条规则触发的，规则是谁在什么时候配置的
- 演进路径可控：支持对模型、流程和规则进行版本化管理，使系统长期演进具备结构性支点。例如，可以创建"审批流程v2.0"进行测试，测试通过后一键切换，必要时还可以回滚到v1.0

#### 3.3.2 可视化并非“图形化”，而是降低系统理解成本

需要强调的是，低代码中的“可视化”并不等同于一次性作用于创建过程的“拖拽式开发”或“所见即所得”的界面设计工具，其核心价值在于在每一次阅读、编写、调试、检查和重构的闭环中，充分降低系统理解与沟通成本。

![image](/DOCUMENT_SITE_LINK_PREFIX_HERE/document-site-files/images/857092bc-61d4-4e04-9cb6-4b270c3c0a5e/image-20260108.8171b5.png?width=800)
*图：可视化呈现的平台内建业务逻辑，开发者可进行改写*

相较于纯文本代码，可视化所依托的是人类对图形化信息的理解能力优势：

- 结构可直接呈现：流程分支、状态转换、数据流向在视觉层面一目了然，避免在多文件、多函数之间跳转理解。例如，一个包含3个并行审批分支和2个条件判断的流程，用代码可能分散在5个类中，而用流程图可以在一个画布上完整呈现
- 语义显式化：业务规则、条件判断和依赖关系被明确标注，而非隐含在实现细节中。例如，一个流程节点标注为"等待总经理审批"，比代码中的waitForApproval(GM)更容易理解
- 认知负担更低：新成员或跨角色（如业务分析师、测试人员）可以在不完全理解技术细节的情况下，理解系统逻辑。业务人员可以直接审查流程图，确认是否符合实际业务规则，而不需要懂Java或SQL，让审查过程上移成为可能

这使得系统的可读性、可理解性和可维护性不再与开发者的个人编码风格强绑定，而更多依赖于平台所提供的统一表达范式。一个典型的场景是：某企业的采购审批流程运行了3年，原开发者已离职。新接手的开发者借助可视化流程设计界面与可视化流程调试功能，用2小时就理解了整个流程的配置，而如果是纯代码实现，可能需要2天时间才能梳理清楚所有的判断逻辑和调用关系。

#### 3.3.3 从“代码规范化”到“结构规范化”

在传统开发模式下，团队规模扩大后，常见的治理手段包括代码规范、分层架构约定、评审流程等。但这类治理本质上是对文本代码的约束，其效果高度依赖执行力度与团队经验，且难以完全消除“千人千面”的实现差异。
例如某团队制定了规范："所有业务规则必须使用规则引擎实现，不允许硬编码在Service层"。但实际执行中：

- 开发者A严格遵守，但实现的规则引擎过于复杂，其他人看不懂
- 开发者B觉得规则太简单，直接用if-else写了，理由是"性能更好"
- 开发者C用了规则引擎，但把规则配置写在了XML文件里，难以维护

低代码平台则将治理前移到结构层：

- 通过统一的模型、流程和规则定义方式，天然收敛实现路径：所有规则都必须通过规则引擎配置，平台**不提供其他方式**
- 将"怎么写代码"转化为"如何组合和配置结构化能力"：开发者关注的是"这条规则的条件和动作是什么"，而不是"用什么设计模式实现"
- 使技术管理的重点从检查代码细节，转向设计合理的抽象与约束：架构师关注的是"规则引擎应该提供哪些能力"，而不是"每段代码是否符合规范"

这种转变的价值并不局限在降低技术要求，而是将复杂性从"个体实现"上移到"平台能力与方法论"层面，更符合企业软件长期演进和多团队协作的需求。

### 3.4 面向企业软件的工程表达方式差异

这种以结构化、可视化为核心的工程表达方式，正是企业软件开发与互联网服务开发在底层方法上的关键差异之一。

- 互联网服务通常对并发量、响应性能和交互复杂度高度敏感，需求相对集中且稳定，能够通过大规模团队与持续投入来消化复杂性。例如，一个电商平台的"秒杀"功能，需要支持每秒数十万次的请求，这需要深度的技术优化（缓存策略、限流算法、分布式锁等），值得投入专门团队持续打磨
- 企业软件则更强调业务差异性、可配置性和长期可维护性，团队规模普遍较小，对变更成本高度敏感。例如，一个制造企业的生产排程系统，用户只有几十人，但排程规则可能因为订单类型、设备状况、人员排班等因素有数十种组合，且每个月都可能需要调整

在后者场景中，仅依赖传统代码与框架，很难在控制成本的同时保证系统质量和演进能力。低代码平台通过结构化与可视化的工程表达，为企业软件提供了一种更适配其现实约束的开发与治理路径。低代码所强调的并不是“开发更快”，而是**更可控地开发、更可持续地演进**。这也决定了它在抽象层级、一致性和工程治理上的侧重点，与互联网服务所采用的开发范式存在本质差异。一个简单的对比：

- 互联网服务：投入100人月优化性能，为1000万用户节省100ms响应时间 → ROI显著
- 企业软件：投入100人月优化性能，为500个用户节省100ms响应时间 → ROI不足；但投入100人月降低变更成本，让未来5年的需求调整成本减半 → ROI显著

可见，低代码试图回应的，并非某一项具体技术挑战，而是企业软件在长期演进过程中不断放大的系统性矛盾。通过提升抽象层级、集中工程复杂度、引入平台可治理的表达形式，低代码为企业软件提供了一种不同于传统开发模式的生产路径。这并不是对专业开发能力的削弱，而是在既有工程经验基础上的一次范式重构。

***

## 四、总结：低代码的历史必然性

回顾企业软件的发展路径可以发现，复杂度并非源于单一技术选择，而是伴随着需求扩张、规模增长和生命周期延长逐步累积的结果。从最早期的硬件导向，到关系型数据库的数据导向，再到高级语言与框架的应用导向，每一次范式转变都是在回应特定阶段的核心矛盾。传统开发模式在小规模下高效，在规模化后却暴露出结构性瓶颈——复杂度分散、实现差异大、长期维护成本高。低代码并不是对高级语言的否定，而是在其长期演进基础上的一次范式跃迁：

- 从代码中心转向意图中心：开发者表达的是"要做什么"，而不是"怎么实现"
- 从个人能力依赖转向平台能力沉淀：通用的工程复杂度由平台统一处理，而不是每个人重复实现
- 从分散复杂度转向集中复杂度：系统知识被结构化、显式化，可被平台理解、分析和治理

正是在这一背景下，低代码成为企业软件领域应对复杂性、成本与规模问题的现实选择。它不是为了让"不会编程的人也能开发软件"，而是为了让专业开发者能够在有限的资源约束下，构建出可长期演进、可持续维护的企业软件系统。这种价值，在系统运行的第3年、第5年、第10年会愈发明显——当初看似"不够灵活"的结构化约束，最终成为系统能够持续演进的关键支撑。
